1. orjson
  a. dev group 이 아닌 main에 설치 요망 => 실제 서버에 사용해야 하므로 ( dev group 기능은 명시된 패키지에 개별적으로 설치할때 쓰이는 기능 )
  b. 벤치마킹 수치 ( 수행속도 ) 가 다른 json 보다 빠르다고 자랑함. -> 이 자료를 그대로 신뢰할수도 있지만 직접 해보는 것이 가장 확실함

2. DTO ( Data Transfer Object )
  a. DTO란? data 를 "전달"하기 위한 목적으로 생성한 객체를 의미
    => data를 수정, 추가, 삭제하는 순간 DTO가 아니게 됨
  b. DTO를 사용하지 않고 Dict를 쓸 경우 발생하는 문제
    • 직접 호출하지 않고는 그 안에 어떤 key와 value가 들어가는지 알 수 없게됨
      => 코드를 읽는 것으로는 동작을 이해할 수 없게 됨
    • 개발 도중에 실수로 key를 누락 하거나, 없는 key를 추가해도 오류를 잡기 쉽지 않음
    • Dict는 기본적으로 Frozen 되어있지 않기 때문에 생성 이후 중간에 값이 바뀌어도 이를 알 수가 없음

결론 : 구현 보다 앞서 스펙을 동료들과 확정하고, 스펙 + 더미 response 먼저 만들어서 배포하자.

3. uuid
  a. uuid4 가 겹칠수 있는 확률은? => 초당 100만 개의 ID를 100년동안 생성할 경우 약 0.000009% 확률로 중복 발생. ( 일반적인 시스템에서는 무시해도 될 수준 )
  b. 영어소문자, 영어대문자, 숫자만을 이용한 ID ( 특수문자 제외 )
    extra) Final : 재할당을 막아놓는 기능 ( ex. abc: Final[str] = "hihi" ) But) mutable 한 객체를 immutable 하게 만들수는 없음

4. Base62, Base64
  a. 
    1. 결과 값에 들어갈 수 있는 문자, 숫자를 미리 지정합니다. 이 값들의 개수가 64개면 base64 가 되고, 62개면 base62 가 됩니다.
    2. 앞으로 “결과 값에 들어갈 수 있는 문자, 숫자” 가 모두 들어있는 문자열을 `base` 라고 부르겠습니다.
    3. 정수를 base_len 으로 1번 나눈 후 몫과 나머지를 구합니다.
    4. base 의 “나머지” 번째 값을 결과에 추가합니다.
    5. 몫이 0이 될 때 까지 반복합니다.
    6. 결과를 문자열로 변환해 리턴합니다.

5. Debuging
  a. 디버깅은 개발자로서 아주 중요한 능력이다.
    - Resume Program: 다음 중단점을 만날때 까지 계속 실행합니다.
    - Step Over: 한 줄 실행합니다.
    - Step Into: 함수 내부로 들어갑니다.
    - Step Into My Code: 함수 내부로 들어가되, 라이브러리 코드등은 무시하고 내 함수 안으로만 들어갑니다.
    - Step Out: 함수 밖으로 빠져나갑니다. 현재 함수를 호출한 쪽으로 이동합니다.
